ungroup() %>%
summarize(issue_count = n())
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue: Coalition", coalition_name, "has non-zero values, but individual party columns are not zero in the same year and section.\n"))
print(issue_rows)
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
}
}
# Apply validation function for each coalition
for (coalition in names(coalitions)) {
validate_coalitions(db, coalition, coalitions[[coalition]])
}
test <- validate_coalitions(list_coalitions)
View(list_coalitions)
#### Coalitions ####
coal <- read_csv("Processed Data/coalition_dic.csv")
# Convert coal to a list format suitable for validation
coalitions <- coal %>%
group_by(coalition_name) %>%
summarize(parties = list(party)) %>%
deframe()
View(coal)
# Clear the environment
rm(list = ls())
library(tidyverse)
###### APPEND 32 Individual final state files to create a single file
# Define the base path
base_path <- "~/Documents/OneDrive/Documents/ITAM/RA - Horacio/Monitoring Brokers/Data/states/"
# Define the state names
states <- c("aguascalientes", "baja", "bajasur", "campeche", "chiapas", "chihuahua",
"coahuila", "colima", "durango", "guanajuato", "guerrero", "hidalgo",
"jalisco", "mexico", "michoacan", "morelos", "nayarit",
"nuevoleon", "oaxaca", "puebla", "queretaro", "quintanaroo",
"sanluispotosi", "sinaloa", "sonora", "tabasco", "tamaulipas",
"tlaxcala","veracruz", "yucatan", "zacatecas")
# Initialize an empty list to store the data frames
df_list <- list()
# Loop through each state, read the data, and append the relevant variables
for (state in states) {
# Construct the file path with the correct naming convention
file_path <- paste0(base_path, state, "/", state, "_FINALV-Brunoâ€™s MacBook Pro.csv")
# Check if the file exists before attempting to read it
if (file.exists(file_path)) {
# Try to read the CSV file and catch any errors
data <- tryCatch({
read.csv(file_path)
}, error = function(e) {
warning(paste("Could not read file:", file_path, "-", e$message))
NULL
})
# Proceed only if data was successfully read and has content
if (!is.null(data) && nrow(data) > 0) {
# Select columns uniqueid, year, section, and those with an underscore, excluding specific terms
data_selected <- data %>%
select(matches(".*_.*")) %>% # Select columns with uniqueid, year, section, and an underscore
select(-matches("vote|party|runnerup|state|incumbent|mutually_exclusive|Partido_Cardenista|Alianza_Just|CI_")) # Exclude specific terms
# Add the data to the list
df_list[[state]] <- data_selected
} else {
warning(paste("File is empty or could not be processed:", file_path))
}
} else {
warning(paste("File does not exist:", file_path))
}
}
# Combine all data frames into one
combined_df <- bind_rows(df_list)
list_coalitions <- as.data.frame(names(combined_df)) %>%
rename(coalitions = "names(combined_df)") %>%
mutate(components = str_split(coalitions, "_")) %>%
unnest_wider(components, names_sep = "_")
# This will create new columns named component_1, component_2, etc.
# Write the combined data frame to a CSV file
write.csv(list_coalitions, "~/Documents/OneDrive/Documents/ITAM/RA - Horacio/Monitoring Brokers/Data/coalition_dic.csv", row.names = FALSE)
View(list_coalitions)
View(list_coalitions)
#### Coalitions ####
coalition_dic <- read_csv("Processed Data/coalition_dic.csv")
c
coal <- read_csv("Processed Data/coalition_dic.csv")
# Convert coal to a list format suitable for validation
coalitions <- coal %>%
group_by(coalition_name) %>%
summarize(parties = list(party)) %>%
deframe()
View(coal)
# Convert coal to a list format suitable for validation
coalitions <- coal %>%
group_by(coalitions) %>%
summarize(parties = list(party)) %>%
deframe()
#### Validations Coalitions ####
validate_coalitions <- function(data, coalition_name, individual_parties) {
issue_rows <- data %>%
group_by(year, section) %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0) %>%
ungroup() %>%
summarize(issue_count = n())
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue: Coalition", coalition_name, "has non-zero values, but individual party columns are not zero in the same year and section.\n"))
print(issue_rows)
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
}
}
# Validate each coalition in coalitions
sink("validation_issues.txt")
for (coalition in names(coalitions)) {
validate_coalitions(db, coalition, coalitions[[coalition]])
}
#### Coalitions ####
coalitions <- read_csv("Processed Data/coalition_dic.csv")
#### Validations Coalitions ####
validate_coalitions <- function(data, coalition_name, individual_parties) {
issue_rows <- data %>%
group_by(year, section) %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0) %>%
ungroup() %>%
summarize(issue_count = n())
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue: Coalition", coalition_name, "has non-zero values, but individual party columns are not zero in the same year and section.\n"))
print(issue_rows)
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
}
}
# Validate each coalition in coalitions
sink("validation_issues.txt")
for (coalition in names(coalitions)) {
validate_coalitions(db, coalition, coalitions[[coalition]])
}
rm(list=ls())
library(readr)
library(stringr)
library(dplyr)
library(writexl)
library(rstudioapi)
library(haven)
# Get the path of the current script
script_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
# Set the working directory to the root of the repository
#Assuming your script is in 'Scripts/Script States/', go two levels up
setwd(file.path(script_dir, "../../../"))
db <- read_csv("Processed Data/aguascalientes/aguascalientes_final.csv")
coalitions <- read_csv("Processed Data/coalition_dic.csv")
#### duplicate values #####
# Check for duplicates
duplicates <- db %>%
group_by(year, section) %>%
filter(n() > 1)
if(nrow(duplicates) > 0) {
print("There are duplicate observations:")
print(duplicates)
} else {
print("No duplicates found.")
}
#### turnout values #####
# Check turnout for reasonable values
invalid_turnout <- db %>%
mutate(turnout = total/listanominal) %>%
select(turnout, everything()) %>%
filter(turnout > 1)
if(nrow(invalid_turnout) > 0) {
print("Turnout values above 1 (100%) detected:")
print(invalid_turnout)
} else {
print("All turnout values are within a reasonable range.")
}
#### NA values #####
#1.
# Columns to include after incumbent_vote
incumbent_related_columns <- c("party_component", "incumbent_party_magar", "incumbent_party_JL", "incumbent_party_Horacio", "incumbent_party_inafed")
# Filter rows with NA in incumbent_vote, excluding other _vote columns
na_incumbent_vote <- db %>%
filter(is.na(incumbent_vote)) %>%
select(incumbent_vote, all_of(incumbent_related_columns), -matches("_vote$"), everything())
print("Rows with NA in 'incumbent_vote':")
print(na_incumbent_vote)
#2.
# Columns to include after state_incumbent_vote
state_incumbent_related_columns <- c("state_year", "state_incumbent_vote_party_component", "state_incumbent_party")
# Filter rows with NA in state_incumbent_vote, excluding other _vote columns
na_state_incumbent_vote <- db %>%
filter(is.na(state_incumbent_vote)) %>%
select(state_incumbent_vote, all_of(state_incumbent_related_columns), -matches("_vote$"), everything())
rm(list=ls())
library(readr)
library(stringr)
library(dplyr)
library(writexl)
library(rstudioapi)
library(haven)
# Get the path of the current script
script_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
# Set the working directory to the root of the repository
#Assuming your script is in 'Scripts/Script States/', go two levels up
setwd(file.path(script_dir, "../../../"))
db <- read_csv("Processed Data/aguascalientes/aguascalientes_final.csv")
coalitions <- read_csv("Processed Data/coalition_dic.csv")
#### duplicate values #####
# Check for duplicates
duplicates <- db %>%
group_by(year, section) %>%
filter(n() > 1)
if(nrow(duplicates) > 0) {
print("There are duplicate observations:")
print(duplicates)
} else {
print("No duplicates found.")
}
#### turnout values #####
# Check turnout for reasonable values
invalid_turnout <- db %>%
mutate(turnout = total/listanominal) %>%
select(turnout, everything()) %>%
filter(turnout > 1)
if(nrow(invalid_turnout) > 0) {
print("Turnout values above 1 (100%) detected:")
print(invalid_turnout)
} else {
print("All turnout values are within a reasonable range.")
}
#### NA values #####
#1.
# Columns to include after incumbent_vote
incumbent_related_columns <- c("party_component", "incumbent_party_magar", "incumbent_party_JL", "incumbent_party_Horacio", "incumbent_party_inafed")
# Filter rows with NA in incumbent_vote, excluding other _vote columns
na_incumbent_vote <- db %>%
filter(is.na(incumbent_vote)) %>%
select(incumbent_vote, all_of(incumbent_related_columns), -matches("_vote$"), everything())
print("Rows with NA in 'incumbent_vote':")
print(na_incumbent_vote)
#2.
# Columns to include after state_incumbent_vote
state_incumbent_related_columns <- c( "state_incumbent_vote_party_component", "state_incumbent_party")
# Filter rows with NA in state_incumbent_vote, excluding other _vote columns
na_state_incumbent_vote <- db %>%
filter(is.na(state_incumbent_vote)) %>%
select(state_incumbent_vote, all_of(state_incumbent_related_columns), -matches("_vote$"), everything())
print("Rows with NA in 'state_incumbent_vote':")
print(na_state_incumbent_vote)
state_validation <- db %>%
select(uniqueid,year,section, state_incumbent_vote, state_incumbent_vote_party_component, state_incumbent_party,)
#3.
# Column to include after PRI_vote
pri_related_column <- "PRI_vote_party_component"
# Filter rows with NA in PRI_vote, excluding other _vote columns
na_PRI_vote <- db %>%
filter(is.na(PRI_vote)) %>%
select(PRI_vote, pri_related_column, -matches("_vote$"), everything())
print("Rows with NA in 'PRI_vote':")
print(na_PRI_vote)
#4.
# Column to include after PRD_vote
prd_related_column <- "PRD_vote_party_component"
# Filter rows with NA in PRD_vote, excluding other _vote columns
na_PRD_vote <- db %>%
filter(is.na(PRD_vote)) %>%
select(PRD_vote, prd_related_column, -matches("_vote$"), everything())
print("Rows with NA in 'PRD_vote':")
print(na_PRD_vote)
#5.
# Column to include after PAN_vote
pan_related_column <- "PAN_vote_party_component"
# Filter rows with NA in PAN_vote, excluding other _vote columns
na_PAN_vote <- db %>%
filter(is.na(PAN_vote)) %>%
select(PAN_vote, pan_related_column, -matches("_vote$"), everything())
print("Rows with NA in 'PAN_vote':")
print(na_PAN_vote)
#6.
# Column to include after MORENA_vote
morena_related_column <- "MORENA_vote_party_component"
# Filter rows with NA in MORENA_vote, excluding other _vote columns
na_MORENA_vote <- db %>%
filter(is.na(MORENA_vote)) %>%
select(MORENA_vote, morena_related_column, -matches("_vote$"), everything())
print("Rows with NA in 'MORENA_vote':")
print(na_MORENA_vote)
#7.
# Columns to include after runnerup_vote
runnerup_related_columns <- c("runnerup_party_magar", "runnerup_party_component")
# Filter rows with NA in runnerup_vote, excluding other _vote columns
na_runnerup_vote <- db %>%
filter(is.na(runnerup_vote)) %>%
select(runnerup_vote, all_of(runnerup_related_columns), -matches("_vote$"), everything())
print("Rows with NA in 'runnerup_vote':")
print(na_runnerup_vote)
#### Coalitions ####
# Convert coal to a list format suitable for validation
coalitions <- coal %>%
group_by(coalitions) %>%
summarize(parties = list(party)) %>%
deframe()
#### Validations Coalitions ####
validate_coalitions <- function(data, coalition_name, individual_parties) {
issue_rows <- data %>%
group_by(year, section) %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0) %>%
ungroup() %>%
summarize(issue_count = n())
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue: Coalition", coalition_name, "has non-zero values, but individual party columns are not zero in the same year and section.\n"))
print(issue_rows)
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
}
}
# Validate each coalition in coalitions
sink("validation_issues.txt")
for (coalition in names(coalitions)) {
validate_coalitions(db, coalition, coalitions[[coalition]])
}
View(coalitions)
# Convert the coalition components into a list format where each coalition name is linked to its non-NA components
coalition_parties <- coalitions %>%
rowwise() %>%
mutate(components = list(na.omit(c(components_1, components_2, components_3, components_4, components_5, components_6, components_7)))) %>%
select(coalitions, components) %>%
deframe()
#### Validation Function ####
validate_coalitions <- function(data, coalition_name, individual_parties) {
issue_rows <- data %>%
group_by(year, section) %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0) %>%
ungroup() %>%
summarize(issue_count = n())
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue: Coalition", coalition_name, "has non-zero values, but individual party columns are not zero in the same year and section.\n"))
print(issue_rows)
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
}
}
# Validate each coalition in coalition_parties
sink("validation_issues.txt")
for (coalition in names(coalition_parties)) {
validate_coalitions(db, coalition, coalition_parties[[coalition]])
}
# Prepare coalition components as a list where each coalition name maps to its components
coalition_parties <- coalitions %>%
rowwise() %>%
mutate(components = list(na.omit(c(components_1, components_2, components_3, components_4, components_5, components_6, components_7)))) %>%
select(coalitions, components) %>%
deframe()
# Validation Function
validate_coalitions <- function(data, coalition_name, individual_parties) {
# Check if the coalition column exists in the data
if (!coalition_name %in% colnames(data)) {
cat(paste("Skipping validation for", coalition_name, "- column not found in db.\n"))
return()
}
# Perform validation
issue_rows <- data %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0)
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue: Coalition", coalition_name, "has non-zero values, but individual party columns are not zero in the same rows.\n"))
print(issue_rows %>% select(year, section, coalition_name, all_of(individual_parties)))
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
}
}
# Apply validation function to each coalition
sink("validation_issues.txt")
for (coalition in names(coalition_parties)) {
validate_coalitions(db, coalition, coalition_parties[[coalition]])
}
sink()
# Apply validation function to each coalition
sink("validation_issues.txt")
for (coalition in names(coalition_parties)) {
validate_coalitions(db, coalition, coalition_parties[[coalition]])
}
sink()
# Apply validation function to each coalition
sink("validation_issues.txt")
for (coalition in names(coalition_parties)) {
validate_coalitions(db, coalition, coalition_parties[[coalition]])
}
sink()
# Prepare coalition components as a list where each coalition name maps to its components
coalition_parties <- coalitions %>%
rowwise() %>%
mutate(components = list(na.omit(c(components_1, components_2, components_3, components_4, components_5, components_6, components_7)))) %>%
select(coalitions, components) %>%
deframe()
# Validation Function
validate_coalitions <- function(data, coalition_name, individual_parties) {
# Check if the coalition column exists in the data
if (!coalition_name %in% colnames(data)) {
cat(paste("Skipping validation for", coalition_name, "- column not found in db.\n"))
return()
}
# Perform validation
issue_rows <- data %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0)
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue for coalition:", coalition_name, "\n"))
print(issue_rows %>% select(year, section, coalition_name, all_of(individual_parties)))
return(issue_rows)
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
return(NULL)
}
}
# Open a file to log issues
output_file <- "validation_issues.txt"
sink(output_file)
validation_issues <- list() # Store issues for summary
# Apply validation function to each coalition
for (coalition in names(coalition_parties)) {
issues <- validate_coalitions(db, coalition, coalition_parties[[coalition]])
if (!is.null(issues)) {
validation_issues[[coalition]] <- issues
}
}
sink()
# Summary feedback
if (length(validation_issues) > 0) {
cat("Validation completed with issues in some coalitions. Check 'validation_issues.txt' for details.\n")
} else {
cat("All coalitions passed validation.\n")
# Optionally delete the empty file if there were no issues
file.remove(output_file)
}
#### Coalitions ####
# Prepare coalition components as a list where each coalition name maps to its components
coalition_parties <- coalitions %>%
rowwise() %>%
mutate(components = list(na.omit(c(components_1, components_2, components_3, components_4, components_5, components_6, components_7)))) %>%
select(coalitions, components) %>%
deframe()
# Validation Function
validate_coalitions <- function(data, coalition_name, individual_parties) {
# Check if the coalition column exists in the data
if (!coalition_name %in% colnames(data)) {
cat(paste("Skipping validation for", coalition_name, "- column not found in db.\n"))
return()
}
# Perform validation
issue_rows <- data %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0)
if (nrow(issue_rows) > 0) {
cat(paste("Validation issue for coalition:", coalition_name, "\n"))
print(issue_rows %>% select(year, section, coalition_name, all_of(individual_parties)))
} else {
cat(paste("Validation passed for coalition:", coalition_name, "\n"))
}
}
# Apply validation function to each coalition
for (coalition in names(coalition_parties)) {
validate_coalitions(db, coalition, coalition_parties[[coalition]])
}
# Summary message after validation
cat("Validation process completed.\n")
# Summary message after validation
cat("Validation process completed.\n")
# Transform the coal data to create a list where each coalition name maps to its components
coalition_parties <- coal %>%
rowwise() %>%
mutate(components = list(na.omit(c(components_1, components_2, components_3, components_4, components_5, components_6, components_7)))) %>%
select(coalitions, components) %>%
deframe()
#### Coalitions ####
# Transform the coal data to create a list where each coalition name maps to its components
coalition_parties <- coalitions %>%
rowwise() %>%
mutate(components = list(na.omit(c(components_1, components_2, components_3, components_4, components_5, components_6, components_7)))) %>%
select(coalitions, components) %>%
deframe()
# Define the validation function
validate_coalitions <- function(data, coalition_name, individual_parties) {
# Check if the coalition column exists in db
if (!coalition_name %in% colnames(data)) {
message(paste("Skipping validation for", coalition_name, "- column not found in db."))
return(NULL)
}
# Filter rows where coalition is non-zero and check individual party columns
issue_rows <- data %>%
filter(!is.na(!!sym(coalition_name)) & !!sym(coalition_name) != 0) %>%
filter(rowSums(across(all_of(individual_parties), ~ . != 0)) > 0)
if (nrow(issue_rows) > 0) {
message(paste("Validation issue for coalition:", coalition_name))
return(issue_rows %>% select(year, section, coalition_name, all_of(individual_parties)))
} else {
message(paste("Validation passed for coalition:", coalition_name))
return(NULL)
}
}
# Run the validation for each coalition and collect issues in a list
validation_issues <- list()
for (coalition in names(coalition_parties)) {
test <- validate_coalitions(db, coalition, coalition_parties[[coalition]])
if (!is.null(test)) {
validation_issues[[coalition]] <- test
}
}
# Check if there were any issues
if (length(validation_issues) > 0) {
message("Validation completed with issues in some coalitions.")
# You can inspect the validation_issues list for details
} else {
message("All coalitions passed validation.")
}
